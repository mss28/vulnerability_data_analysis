#!/usr/bin/env python
# -*- coding: utf-8 -*-
import json
import re
import time
import redis
import requests
import traceback

localRedis = redis.StrictRedis(host='redis', port=6379, decode_responses=True)

download_url_template = "https://raw.githubusercontent.com/{:s}/{:s}/package.json"
npm_search_url_template = 'https://api.github.com/search/code?q={:s} in:file path:/+extension:json+filename:package.json&sort=stars&order=desc&page={:d}'

auth_user = '' # put git user name
auth_pass = '' # put git password

# Redis keys
ALL_LIBS = "all_libs"  # store name all libraries
LIB_STAT_KEY = '{:s}.is_loaded'  # store loading status of a library
SLEEP_DURATION = 60


def page_visit_torify(url):
    session = requests.session()
    session.proxies = {'http': 'socks5h://localhost:9050', 'https': 'socks5h://localhost:9050'}

    return session.get(url)


def get_download_ur(html_url):
    result = re.search(r'^https://github.com/(.*)/blob/(.*)/package\.json$', html_url)

    download_url = None
    if result:
        repo_id, commit_hash = result.groups()
        download_url = download_url_template.format(repo_id, commit_hash)

    return download_url


def download_file(download_url):
    # make sure to service tor start
    # req = requests.get(download_url)
    req = page_visit_torify(download_url)
    return json.loads(req.text.encode('utf-8').decode("utf8"))


def find_library_version(target_lib_name, package_json):
    dependencies = package_json.get('dependencies')

    if dependencies is None:
        dependencies = package_json.get('devDependencies')
    if dependencies is None:
        dependencies = package_json.get('optionalDependencies')
    if dependencies is None:
        dependencies = package_json.get('bundledDependencies')
    if dependencies is None:
        dependencies = package_json.get('peerDependencies')

    if dependencies is None:
        return None
    else:
        return dependencies.get(target_lib_name, None)


def get_req_status(req):
    headers = req.headers

    # print("\t***Headers***")
    # print(headers)
    # print("***---***")

    status_code = headers['Status']
    status, last = False, 0

    if status_code == "200 OK":
        status = True
        if 'Link' in headers:
            last = int(
                re.search(r'<https://api.github.com/search/code.*page=(.*)>; rel="last"', headers['Link']).groups()[0]
            )
    elif status_code == "422 Unprocessable Entity":
        raise Exception(status_code)

    return status, last


def search(target_lib_name, output_file):
    print('\tSearching for the library: {:s}'.format(target_lib_name))
    current_page = 1
    max_page = 1

    while current_page <= max_page:
        url = npm_search_url_template.format(target_lib_name, current_page)
        req, status, last_page = None, False, 0
        while not status:
            req = requests.get(url, auth=(auth_user, auth_pass))
            status, last_page = get_req_status(req)

            if not status:
                print(
                    "\t......................Putting to sleep for {:d} seconds......................".format(
                        SLEEP_DURATION)
                )
                time.sleep(SLEEP_DURATION)

        max_page = last_page
        r = json.loads(req.text.encode('utf-8').decode("utf8"))

        for item in r['items']:
            repo = item['repository']
            html_url = item['html_url']
            download_url = get_download_ur(html_url)

            if download_url is not None:
                package_json = download_file(download_url)
                lib_version = find_library_version(target_lib_name, package_json)
                result = {
                    "repo_id": repo['id'],
                    "repo_name": "https://github.com/{:s}".format(repo['full_name']),
                    "lib_version": lib_version
                }

                output_file.write('{:s}, "{:s}"', "{:s}", result['repo_id'], result['repo_name'], result['lib_version'])
                localRedis.set('repo.result.' + str(result['repo_id']), json.dumps(result))

                print('\t' + str(result))

            repository_id = repo['id']
            localRedis.sadd('repo_ids', repository_id)
            localRedis.set('repo.' + str(repository_id), json.dumps(item))


def read_json(file_path):
    with open(file_path, 'r') as file:
        data = file.read()

    return json.loads(data)


def store_list(data):
    for d in data:
        localRedis.sadd(ALL_LIBS, d['lib_name'])


def run(input_file_path, start, end):
    data = read_json(input_file_path)
    store_list(data)

    all_data = list(localRedis.smembers(ALL_LIBS))
    all_data.sort()
    sliced_data = all_data[start - 1: end]

    output_file = open("../data/vulnerabilities.csv", "a")
    counter = start
    for lib_name in sliced_data:
        print('Loading the library: {:s}'.format(lib_name))

        key = LIB_STAT_KEY.format(lib_name)

        is_loaded = localRedis.get(key)
        if is_loaded is None:
            is_loaded = 0
        else:
            is_loaded = int(is_loaded)

        # 0 not loaded
        # 1 on going
        # 2 failed
        # 3 completed
        if is_loaded == 3:
            print('\t{:d}. {:s} already loaded'.format(counter, lib_name))
        else:
            try:
                localRedis.set(key, 1)
                search(lib_name, output_file)
            except Exception:
                print("\t", end='')
                traceback.print_exc()
                print('\t{:d}. {:s} failed'.format(counter, lib_name))
                localRedis.set(key, 2)
            else:
                print('\t{:d}. {:s} completed'.format(counter, lib_name))
                localRedis.set(key, 3)

        counter += 1


if __name__ == "__main__":

    should_run = True
    # TODO: Take git credentials from console input
    if auth_user == '':
        should_run = False
        print('Provide git user name')
    if auth_pass == '':
        should_run = False
        print('Provide git password')

    start_num = int(input("Start number:"))
    end_num = int(input("End number:"))

    if should_run:
        run('../data/npm_advisories.json', start_num, end_num)
    else:
        print('Not ready to run, check messages')
